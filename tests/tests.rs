#[macro_use]
mod common;

make_test!(var: r"let x = 0; x" => "0");
make_test!(func: r"let f(x) = x + 1; f(2)" => "3");
make_test!(func2: r"let f(x)(y) = x * y + x + y; f(3)(4)" => "19");
make_test!(pipe: r"let f(x)(y) = x + y; 1 | f(2)" => "3");
make_test!(pipe_twice: r"let f(x) = x + 1; let g(x) = x * 2; 1 | f | g" => "4");
make_test!(pipe_nested: r"let f(x)(y) = x + y; 1 | (2 | f)" => "3");
make_test!(func_var: r"let f(x) = x * x; let g = f; g(3)" => "9");
make_test!(arithmetic: "1 + 2 * 2 * 3 / 4 * 5 - 6 + 7" => "17");
make_test!(func_noargs1: r"let f() = 3; f()" => "3");
make_test!(func_noargs2: r"let f() = 3; f(1)" => "3");
make_test!(func_noargs3: r"let f(x) = x; f()" => "null");
make_fail_test!(no_same_arg_name: "let f(x)(x) = 3; f(1)(2)");
make_fail_test!(#[ignore] no_same_arg_name_unused: "let f(x)(x) = 3; null");
make_test!(allow_same_arg_name_nested_func: "let f(x) = (let g(x) = x; g); f(1)(2)" => "2");
make_parsefail_test!(empty_script: "");
make_fail_test!(no_overload: "let x = 3; let x = 3; let f(x) = x; let f(x) = x; null");
make_test!(overload_in_block: "let x = 3; (let x = 4; x) + x" => "7");
make_test!(overload_in_func: "let x = 3; let f(y) = (let x = 4; x + y); f(1)" => "5");
make_test!(func_in_func: "let f(x) = (let g(y) = [x, y]; g); f(1)(2)" => "[1, 2]");
make_test!(func_defsite_scope: "let f = (let y = 3; let f() = y; f); f()" => "3");
make_fail_test!(func_no_callsite_scope: "let f(x) = y; let y = 3; f()");
make_test!(scope_func_nested1: "let x = 3; (let y = 4; scope())" => r#" {"true":true,"false":false,"null":null,"x":3,"y":4} "#);
make_test!(scope_func_nested2: "let x = 3; (let y = 4; local_scope())" => r#" {"y":4} "#);
make_test!(scope_func_block: "let x = 3; let s = local_scope(); (let y = 4; s)" => r#" {"x":3} "#);
make_test!(var_path: "let x = { y: { z: 3 } }; x.y.z" => "3");
make_test!(var_path_null_propagation: "let x = { y: null }; x?.y?.z" => "null");
make_test!(var_path_null_propagation2: "let x = null; x?.y.z" => "null");
make_test!(var_path_null_propagation_not_null: "let x = { y: { z: 3 } }; x?.y?.z" => "3");
make_test!(null_propagated_invoke_null: "let f = null; f?()" => "null");
make_test!(null_propagated_invoke_null_fn: "let f() = null; f()?.x.y.z" => "null");
make_fail_test!(not_null_propagated_invoke_null: "let f = null; f()");
make_test!(dynamic_access: r#"let x = "a"; let z = "c"; {a:{y:{c:3,z:5}}}[x].y[z] "# => "3");
make_test!(array_access: "[10, 11, 12][1]" => "11");
make_test!(array_str_access: r#"[10, 11, 12]["1"]"# => "11");
make_fail_test!(null_no_propagate_through_var: "let x = null?; x.y");
make_fail_test!(null_no_propagate_through_block: "(null?).y");
make_fail_test!(null_no_propagate_through_func: "let f() = null?; f().y");
make_fail_test!(null_no_propagate_through_arg: "let f(x) = x.y; f(null?)");
make_test!(lambda_function1: "(x => x + x)(3)" => "6");
make_test!(lambda_function2: "(x => y => x + y)(3)(4)" => "7");
make_test!(empty_lambda: "(_ => x)" => "null");
make_fail_test!(null_no_propagate_through_lambda: "(x => null?)().x");
make_test!(lambda_allow_param_shadow_var: "let x = 3; (x => x + 2)(4)" => "6");
